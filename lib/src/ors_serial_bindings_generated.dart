// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObject>
_ORSSerialPortBindings_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ORSSerialPortBindings_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ORSSerialPortBindings_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external void _ORSSerialPortBindings_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ORSSerialPortBindings_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ORSSerialPortBindings_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external void _ORSSerialPortBindings_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ORSSerialPortBindings_wrapListenerBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_ORSSerialPortBindings_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external void _ORSSerialPortBindings_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
);

enum NSTextCheckingType {
  NSTextCheckingTypeOrthography(1),
  NSTextCheckingTypeSpelling(2),
  NSTextCheckingTypeGrammar(4),
  NSTextCheckingTypeDate(8),
  NSTextCheckingTypeAddress(16),
  NSTextCheckingTypeLink(32),
  NSTextCheckingTypeQuote(64),
  NSTextCheckingTypeDash(128),
  NSTextCheckingTypeReplacement(256),
  NSTextCheckingTypeCorrection(512),
  NSTextCheckingTypeRegularExpression(1024),
  NSTextCheckingTypePhoneNumber(2048),
  NSTextCheckingTypeTransitInformation(4096);

  final int value;
  const NSTextCheckingType(this.value);

  static NSTextCheckingType fromValue(int value) => switch (value) {
    1 => NSTextCheckingTypeOrthography,
    2 => NSTextCheckingTypeSpelling,
    4 => NSTextCheckingTypeGrammar,
    8 => NSTextCheckingTypeDate,
    16 => NSTextCheckingTypeAddress,
    32 => NSTextCheckingTypeLink,
    64 => NSTextCheckingTypeQuote,
    128 => NSTextCheckingTypeDash,
    256 => NSTextCheckingTypeReplacement,
    512 => NSTextCheckingTypeCorrection,
    1024 => NSTextCheckingTypeRegularExpression,
    2048 => NSTextCheckingTypePhoneNumber,
    4096 => NSTextCheckingTypeTransitInformation,
    _ => throw ArgumentError('Unknown value for NSTextCheckingType: $value'),
  };
}

enum NSRegularExpressionOptions {
  NSRegularExpressionCaseInsensitive(1),
  NSRegularExpressionAllowCommentsAndWhitespace(2),
  NSRegularExpressionIgnoreMetacharacters(4),
  NSRegularExpressionDotMatchesLineSeparators(8),
  NSRegularExpressionAnchorsMatchLines(16),
  NSRegularExpressionUseUnixLineSeparators(32),
  NSRegularExpressionUseUnicodeWordBoundaries(64);

  final int value;
  const NSRegularExpressionOptions(this.value);

  static NSRegularExpressionOptions fromValue(int value) => switch (value) {
    1 => NSRegularExpressionCaseInsensitive,
    2 => NSRegularExpressionAllowCommentsAndWhitespace,
    4 => NSRegularExpressionIgnoreMetacharacters,
    8 => NSRegularExpressionDotMatchesLineSeparators,
    16 => NSRegularExpressionAnchorsMatchLines,
    32 => NSRegularExpressionUseUnixLineSeparators,
    64 => NSRegularExpressionUseUnicodeWordBoundaries,
    _ => throw ArgumentError(
      'Unknown value for NSRegularExpressionOptions: $value',
    ),
  };
}

/// WARNING: NSRegularExpression is a stub. To generate bindings for this class, include
/// NSRegularExpression in your config's objc-interfaces list.
///
/// NSRegularExpression
class NSRegularExpression extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSRegularExpression._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSRegularExpression',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
  }

  /// Constructs a [NSRegularExpression] that points to the same underlying object as [other].
  NSRegularExpression.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSRegularExpression] that wraps the given raw object pointer.
  NSRegularExpression.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum NSMatchingOptions {
  NSMatchingReportProgress(1),
  NSMatchingReportCompletion(2),
  NSMatchingAnchored(4),
  NSMatchingWithTransparentBounds(8),
  NSMatchingWithoutAnchoringBounds(16);

  final int value;
  const NSMatchingOptions(this.value);

  static NSMatchingOptions fromValue(int value) => switch (value) {
    1 => NSMatchingReportProgress,
    2 => NSMatchingReportCompletion,
    4 => NSMatchingAnchored,
    8 => NSMatchingWithTransparentBounds,
    16 => NSMatchingWithoutAnchoringBounds,
    _ => throw ArgumentError('Unknown value for NSMatchingOptions: $value'),
  };
}

enum NSMatchingFlags {
  NSMatchingProgress(1),
  NSMatchingCompleted(2),
  NSMatchingHitEnd(4),
  NSMatchingRequiredEnd(8),
  NSMatchingInternalError(16);

  final int value;
  const NSMatchingFlags(this.value);

  static NSMatchingFlags fromValue(int value) => switch (value) {
    1 => NSMatchingProgress,
    2 => NSMatchingCompleted,
    4 => NSMatchingHitEnd,
    8 => NSMatchingRequiredEnd,
    16 => NSMatchingInternalError,
    _ => throw ArgumentError('Unknown value for NSMatchingFlags: $value'),
  };
}

enum NSTimeZoneNameStyle {
  NSTimeZoneNameStyleStandard(0),
  NSTimeZoneNameStyleShortStandard(1),
  NSTimeZoneNameStyleDaylightSaving(2),
  NSTimeZoneNameStyleShortDaylightSaving(3),
  NSTimeZoneNameStyleGeneric(4),
  NSTimeZoneNameStyleShortGeneric(5);

  final int value;
  const NSTimeZoneNameStyle(this.value);

  static NSTimeZoneNameStyle fromValue(int value) => switch (value) {
    0 => NSTimeZoneNameStyleStandard,
    1 => NSTimeZoneNameStyleShortStandard,
    2 => NSTimeZoneNameStyleDaylightSaving,
    3 => NSTimeZoneNameStyleShortDaylightSaving,
    4 => NSTimeZoneNameStyleGeneric,
    5 => NSTimeZoneNameStyleShortGeneric,
    _ => throw ArgumentError('Unknown value for NSTimeZoneNameStyle: $value'),
  };
}

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
class NSUUID extends objc.NSObject
    implements objc.NSCopying, objc.NSSecureCoding {
  NSUUID._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUUID',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
  }

  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

/// #define LOG_SERIAL_PORT_ERRORS
enum ORSSerialPortParity {
  ORSSerialPortParityNone(0),
  ORSSerialPortParityOdd(1),
  ORSSerialPortParityEven(2);

  final int value;
  const ORSSerialPortParity(this.value);

  static ORSSerialPortParity fromValue(int value) => switch (value) {
    0 => ORSSerialPortParityNone,
    1 => ORSSerialPortParityOdd,
    2 => ORSSerialPortParityEven,
    _ => throw ArgumentError('Unknown value for ORSSerialPortParity: $value'),
  };
}

late final _class_ORSSerialPort = objc.getClass("ORSSerialPort");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_serialPortWithPath_ = objc.registerName("serialPortWithPath:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_serialPortWithDevice_ = objc.registerName(
  "serialPortWithDevice:",
);
final _objc_msgSend_degb40 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedInt,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_initWithPath_ = objc.registerName("initWithPath:");
late final _sel_initWithDevice_ = objc.registerName("initWithDevice:");
late final _sel_open = objc.registerName("open");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_close = objc.registerName("close");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_cleanup = objc.registerName("cleanup");
late final _sel_cleanupAfterSystemRemoval = objc.registerName(
  "cleanupAfterSystemRemoval",
);
late final _sel_sendData_ = objc.registerName("sendData:");

/// WARNING: ORSSerialRequest is a stub. To generate bindings for this class, include
/// ORSSerialRequest in your config's objc-interfaces list.
///
/// ORSSerialRequest
class ORSSerialRequest extends objc.ObjCObjectBase {
  ORSSerialRequest._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [ORSSerialRequest] that points to the same underlying object as [other].
  ORSSerialRequest.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ORSSerialRequest] that wraps the given raw object pointer.
  ORSSerialRequest.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_sendRequest_ = objc.registerName("sendRequest:");
late final _sel_cancelQueuedRequest_ = objc.registerName(
  "cancelQueuedRequest:",
);
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_cancelAllQueuedRequests = objc.registerName(
  "cancelAllQueuedRequests",
);
late final _class_ORSSerialPacketDescriptor = objc.getClass(
  "ORSSerialPacketDescriptor",
);
bool _ObjCBlock_bool_NSData_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) => block.ref.target
    .cast<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0)>
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_NSData_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_bool_NSData_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_NSData_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCObject> arg0,
) =>
    (objc.getBlockClosure(block)
        as bool Function(ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_NSData_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_bool_NSData_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(objc.NSData?)>`.
abstract final class ObjCBlock_bool_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSData?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(objc.NSData?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSData?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(objc.NSData?)>(
    objc.newPointerBlock(_ObjCBlock_bool_NSData_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSData?)> fromFunction(
    bool Function(objc.NSData?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(objc.NSData?)>(
    objc.newClosureBlock(
      _ObjCBlock_bool_NSData_closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.castFromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(objc.NSData?)>`.
extension ObjCBlock_bool_NSData_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(objc.NSData?)> {
  bool call(objc.NSData? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_initWithMaximumPacketLength_userInfo_responseEvaluator_ = objc
    .registerName("initWithMaximumPacketLength:userInfo:responseEvaluator:");
final _objc_msgSend_eeseq3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_initWithPacketData_userInfo_ = objc.registerName(
  "initWithPacketData:userInfo:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_initWithPrefix_suffix_maximumPacketLength_userInfo_ = objc
    .registerName("initWithPrefix:suffix:maximumPacketLength:userInfo:");
final _objc_msgSend_1cqwhro = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_initWithPrefixString_suffixString_maximumPacketLength_userInfo_ =
    objc.registerName(
      "initWithPrefixString:suffixString:maximumPacketLength:userInfo:",
    );
late final _sel_initWithRegularExpression_maximumPacketLength_userInfo_ = objc
    .registerName("initWithRegularExpression:maximumPacketLength:userInfo:");
final _objc_msgSend_dqtc6u = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_dataIsValidPacket_ = objc.registerName("dataIsValidPacket:");
late final _sel_packetMatchingAtEndOfBuffer_ = objc.registerName(
  "packetMatchingAtEndOfBuffer:",
);
late final _sel_packetData = objc.registerName("packetData");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_prefix = objc.registerName("prefix");
late final _sel_suffix = objc.registerName("suffix");
late final _sel_regularExpression = objc.registerName("regularExpression");
late final _sel_maximumPacketLength = objc.registerName("maximumPacketLength");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_userInfo = objc.registerName("userInfo");
late final _sel_uuid = objc.registerName("uuid");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
    >()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
_ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
) =>
    (objc.getBlockClosure(block)
        as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >(_ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newPointerBlock(
          _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
  >
  fromFunction(
    objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
      >(
        objc.newClosureBlock(
          _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
          (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)
        > {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");

/// ORSSerialPacketDescriptor
class ORSSerialPacketDescriptor extends objc.NSObject {
  ORSSerialPacketDescriptor._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ORSSerialPacketDescriptor] that points to the same underlying object as [other].
  ORSSerialPacketDescriptor.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ORSSerialPacketDescriptor] that wraps the given raw object pointer.
  ORSSerialPacketDescriptor.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ORSSerialPacketDescriptor].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_ORSSerialPacketDescriptor,
    );
  }

  /// Creates an initializes an ORSSerialPacketDescriptor instance using a response evaluator block.
  ///
  /// This initializer can be used to creat a packet descriptor with complex packet matching
  /// rules. For most packet formats, the initializers that take prefix and suffix, or regular expression
  /// are easier to use. However, if the packet format cannot be described using a simple prefix/suffix
  /// or regular expression, a response evaulator block containing arbitrary validation code can be
  /// provided instead.
  ///
  /// @param maxPacketLength The maximum length of a valid packet. This value _must_ be correctly specified.
  /// @param userInfo          An arbitrary userInfo object.
  /// @param responseEvaluator A block used to evaluate whether received data constitutes a valid packet.
  ///
  /// @return An initizliaized ORSSerialPacketDesciptor instance.
  ///
  /// @see -initWithPrefix:suffix:maximumPacketLength:userInfo:
  /// @see -initWithPrefixString:suffixString:maximumPacketLength:userInfo:
  /// @see -initWithRegularExpression:maximumPacketLength:userInfo:
  ORSSerialPacketDescriptor initWithMaximumPacketLength(
    int maxPacketLength, {
    objc.ObjCObjectBase? userInfo,
    required objc.ObjCBlock<ffi.Bool Function(objc.NSData?)> responseEvaluator,
  }) {
    final _ret = _objc_msgSend_eeseq3(
      this.ref.retainAndReturnPointer(),
      _sel_initWithMaximumPacketLength_userInfo_responseEvaluator_,
      maxPacketLength,
      userInfo?.ref.pointer ?? ffi.nullptr,
      responseEvaluator.ref.pointer,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// Creates an initializes an ORSSerialPacketDescriptor instance using fixed packet data.
  ///
  /// This can be used to create a packet descriptor for packets which consist of a fixed sequence of data.
  ///
  /// @param packetData	An NSData instance containing a fixed sequence of bytes making up a packet.
  /// @param userInfo		An arbitrary userInfo object. May be nil.
  ///
  /// @return An initizliaized ORSSerialPacketDesciptor instance.
  ORSSerialPacketDescriptor initWithPacketData(
    objc.NSData packetData, {
    objc.ObjCObjectBase? userInfo,
  }) {
    final _ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPacketData_userInfo_,
      packetData.ref.pointer,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// Creates an initializes an ORSSerialPacketDescriptor instance using a prefix and/or suffix.
  ///
  /// If the packet format uses printable ASCII characters,
  /// -initWithPrefixString:suffixString:maximumPacketLength:userInfo: may be more suitable.
  ///
  /// @note Either prefix or suffix may be nil, but not both. If the suffix is nil,
  /// packets will be considered to consist solely of prefix. If either value is nil, packets
  /// will be considred to consist soley of the the non-nil value.
  ///
  /// @param prefix   An NSData instance containing a fixed packet prefix. May be nil.
  /// @param suffix   An NSData instance containing a fixed packet suffix. May be nil.
  /// @param maxPacketLength The maximum length of a valid packet. This value _must_ be correctly specified.
  /// @param userInfo An arbitrary userInfo object. May be nil.
  ///
  /// @return An initizliaized ORSSerialPacketDesciptor instance.
  ///
  /// @see -initWithPrefixString:suffixString:userInfo:
  ORSSerialPacketDescriptor initWithPrefix(
    objc.NSData? prefix, {
    objc.NSData? suffix,
    required int maximumPacketLength,
    objc.ObjCObjectBase? userInfo,
  }) {
    final _ret = _objc_msgSend_1cqwhro(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPrefix_suffix_maximumPacketLength_userInfo_,
      prefix?.ref.pointer ?? ffi.nullptr,
      suffix?.ref.pointer ?? ffi.nullptr,
      maximumPacketLength,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// Creates an initializes an ORSSerialPacketDescriptor instance using a prefix string and/or suffix string.
  ///
  /// This method assumes that prefixString and suffixString are ASCII or UTF8 strings.
  /// If the packet format does not use printable ASCII characters, -initWithPrefix:suffix:maximumPacketLength:userInfo:
  /// may be more suitable.
  ///
  /// @note Either prefixString or suffixString may be nil, but not both. If the suffix is nil,
  /// packets will be considered to consist solely of prefix. If either value is nil, packets
  /// will be considred to consist soley of the the non-nil value.
  ///
  /// @param prefixString A fixed packet prefix string. May be nil.
  /// @param suffixString A fixed packet suffix string. May be nil.
  /// @param maxPacketLength The maximum length of a valid packet. This value _must_ be correctly specified.
  /// @param userInfo     An arbitrary userInfo object. May be nil.
  ///
  /// @return An initizliaized ORSSerialPacketDesciptor instance.
  ///
  /// @see -initWithPrefix:suffix:maximumPacketLength:userInfo:
  ORSSerialPacketDescriptor initWithPrefixString(
    objc.NSString? prefixString, {
    objc.NSString? suffixString,
    required int maximumPacketLength,
    objc.ObjCObjectBase? userInfo,
  }) {
    final _ret = _objc_msgSend_1cqwhro(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPrefixString_suffixString_maximumPacketLength_userInfo_,
      prefixString?.ref.pointer ?? ffi.nullptr,
      suffixString?.ref.pointer ?? ffi.nullptr,
      maximumPacketLength,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// Creates an initializes an ORSSerialPacketDescriptor instance using a regular expression.
  ///
  /// A packet is considered valid as long as it contains at least one match for the provided
  /// regular expression. For this reason, the regex should match as conservatively (smallest match) as possible.
  ///
  /// Packets described by descriptors created using this method are assumed to be ASCII or UTF8 strings.
  /// If your packets are not naturally represented as strings, consider using
  /// -initWithMaximumPacketLength:userInfo:responseEvaluator: instead.
  ///
  /// @param regex    An NSRegularExpression instance for which valid packets are a match.
  /// @param maxPacketLength The maximum length of a valid packet. This value _must_ be correctly specified.
  /// @param userInfo An arbitrary userInfoObject. May be nil.
  ///
  /// @return An initizliaized ORSSerialPacketDesciptor instance.
  ORSSerialPacketDescriptor initWithRegularExpression(
    NSRegularExpression regex, {
    required int maximumPacketLength,
    objc.ObjCObjectBase? userInfo,
  }) {
    final _ret = _objc_msgSend_dqtc6u(
      this.ref.retainAndReturnPointer(),
      _sel_initWithRegularExpression_maximumPacketLength_userInfo_,
      regex.ref.pointer,
      maximumPacketLength,
      userInfo?.ref.pointer ?? ffi.nullptr,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// Can be used to determine if a block of data is a valid packet matching the descriptor encapsulated
  /// by the receiver.
  ///
  /// @param packetData Data received from a serial port.
  ///
  /// @return YES if the data is a valid packet, NO otherwise.
  bool dataIsValidPacket(objc.NSData? packetData) {
    return _objc_msgSend_19nvye5(
      this.ref.pointer,
      _sel_dataIsValidPacket_,
      packetData?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Can be used to determine and extract a packet from a buffer, matching up to the end of the buffer.
  ///
  /// @param buffer Data received from serial port.
  ///
  /// @return Data corresponding to valid packet, or nil.
  objc.NSData? packetMatchingAtEndOfBuffer(objc.NSData? buffer) {
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_packetMatchingAtEndOfBuffer_,
      buffer?.ref.pointer ?? ffi.nullptr,
    );
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// The fixed packetData for packets described by the receiver. Will be nil for packet
  /// descriptors not created using -initWithPacketData:userInfo:
  objc.NSData? get packetData {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_packetData);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// The prefix for packets described by the receiver. Will be nil for packet
  /// descriptors not created using one of the prefix/suffix initializer methods.
  objc.NSData? get prefix {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_prefix);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// The suffix for packets described by the receiver. Will be nil for packet
  /// descriptors not created using one of the prefix/suffix initializer methods.
  objc.NSData? get suffix {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_suffix);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// A regular expression matching packets described by the receiver. Will be nil
  /// for packet descriptors not created using -initWithRegularExpression:userInfo:.
  NSRegularExpression? get regularExpression {
    final _ret = _objc_msgSend_151sglz(
      this.ref.pointer,
      _sel_regularExpression,
    );
    return _ret.address == 0
        ? null
        : NSRegularExpression.castFromPointer(
            _ret,
            retain: true,
            release: true,
          );
  }

  /// The maximum lenght of a packet described by the receiver.
  int get maximumPacketLength {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_maximumPacketLength);
  }

  /// Arbitrary object (e.g. NSDictionary) used to store additional data
  /// about the packet descriptor.
  objc.ObjCObjectBase? get userInfo {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_userInfo);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Unique identifier for the descriptor.
  NSUUID get uuid {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_uuid);
    return NSUUID.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  ORSSerialPacketDescriptor init() {
    objc.checkOsVersionInternal(
      'ORSSerialPacketDescriptor.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_151sglz(
      this.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static ORSSerialPacketDescriptor new$() {
    final _ret = _objc_msgSend_151sglz(
      _class_ORSSerialPacketDescriptor,
      _sel_new,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static ORSSerialPacketDescriptor allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final _ret = _objc_msgSend_1cwp428(
      _class_ORSSerialPacketDescriptor,
      _sel_allocWithZone_,
      zone,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// alloc
  static ORSSerialPacketDescriptor alloc() {
    final _ret = _objc_msgSend_151sglz(
      _class_ORSSerialPacketDescriptor,
      _sel_alloc,
    );
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// self
  ORSSerialPacketDescriptor self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// retain
  ORSSerialPacketDescriptor retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// autorelease
  ORSSerialPacketDescriptor autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ORSSerialPacketDescriptor.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// Returns a new instance of ORSSerialPacketDescriptor constructed with the default `new` method.
  factory ORSSerialPacketDescriptor() => new$();
}

late final _sel_startListeningForPacketsMatchingDescriptor_ = objc.registerName(
  "startListeningForPacketsMatchingDescriptor:",
);
late final _sel_stopListeningForPacketsMatchingDescriptor_ = objc.registerName(
  "stopListeningForPacketsMatchingDescriptor:",
);
late final _protocol_ORSSerialPortDelegate = objc.getProtocol(
  "ORSSerialPortDelegate",
);
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocol>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocol>,
      )
    >();
late final _sel_serialPortWasRemovedFromSystem_ = objc.registerName(
  "serialPortWasRemovedFromSystem:",
);
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
    >()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) =>
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
    );
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  (objc.getBlockClosure(block)
      as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
    );
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>(
    objc.newPointerBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_fnPtrCallable,
      ptr.cast(),
    ),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>(
    objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_listenerCallable.nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingCallable.nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_blockingListenerCallable
          .nativeFunction
          .cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort)> {
  void call(ffi.Pointer<ffi.Void> arg0, ORSSerialPort arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_serialPort_didReceiveData_ = objc.registerName(
  "serialPort:didReceiveData:",
);
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  (objc.getBlockClosure(block)
      as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      ))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_listenerTrampoline,
      )
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingTrampoline,
      )
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
      >(
        objc.newPointerBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          ) => fn(
            arg0,
            ORSSerialPort.castFromPointer(arg1, retain: true, release: true),
            objc.NSData.castFromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_listenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_blockingListenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, ORSSerialPort arg1, objc.NSData arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_serialPort_didReceivePacket_matchingDescriptor_ = objc
    .registerName("serialPort:didReceivePacket:matchingDescriptor:");
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<objc.ObjCObject> arg3,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_fnPtrTrampoline,
        )
        .cast();
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) =>
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_closureTrampoline,
        )
        .cast();
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) {
  (objc.getBlockClosure(block)
      as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      ))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_listenerTrampoline,
      )
      ..keepIsolateAlive = false;
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingTrampoline,
      )
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          objc.NSData,
          ORSSerialPacketDescriptor,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<objc.ObjCObject> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          objc.NSData,
          ORSSerialPacketDescriptor,
        )
      >(
        objc.newPointerBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          objc.NSData,
          ORSSerialPacketDescriptor,
        )
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
          ) => fn(
            arg0,
            ORSSerialPort.castFromPointer(arg1, retain: true, release: true),
            objc.NSData.castFromPointer(arg2, retain: true, release: true),
            ORSSerialPacketDescriptor.castFromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_listenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
        ORSSerialPacketDescriptor.castFromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ORSSerialPort,
        objc.NSData,
        ORSSerialPacketDescriptor,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialPacketDescriptor,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
        ORSSerialPacketDescriptor.castFromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_blockingListenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
        ORSSerialPacketDescriptor.castFromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ORSSerialPort,
        objc.NSData,
        ORSSerialPacketDescriptor,
      )
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ORSSerialPort,
            objc.NSData,
            ORSSerialPacketDescriptor,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    ORSSerialPort arg1,
    objc.NSData arg2,
    ORSSerialPacketDescriptor arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_serialPort_didReceiveResponse_toRequest_ = objc.registerName(
  "serialPort:didReceiveResponse:toRequest:",
);
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<objc.ObjCObject> arg3,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_fnPtrTrampoline,
        )
        .cast();
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) =>
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_closureTrampoline,
        )
        .cast();
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) {
  (objc.getBlockClosure(block)
      as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      ))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_listenerTrampoline,
      )
      ..keepIsolateAlive = false;
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<objc.ObjCObject> arg3,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingTrampoline,
      )
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData, ORSSerialRequest)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          objc.NSData,
          ORSSerialRequest,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<objc.ObjCObject> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          objc.NSData,
          ORSSerialRequest,
        )
      >(
        objc.newPointerBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          objc.NSData,
          ORSSerialRequest,
        )
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
          ) => fn(
            arg0,
            ORSSerialPort.castFromPointer(arg1, retain: true, release: true),
            objc.NSData.castFromPointer(arg2, retain: true, release: true),
            ORSSerialRequest.castFromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_listenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
        ORSSerialRequest.castFromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ORSSerialPort,
        objc.NSData,
        ORSSerialRequest,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      ORSSerialPort,
      objc.NSData,
      ORSSerialRequest,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
        ORSSerialRequest.castFromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_blockingListenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSData.castFromPointer(arg2, retain: false, release: true),
        ORSSerialRequest.castFromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        ORSSerialPort,
        objc.NSData,
        ORSSerialRequest,
      )
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSData, ORSSerialRequest)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ORSSerialPort,
            objc.NSData,
            ORSSerialRequest,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    ORSSerialPort arg1,
    objc.NSData arg2,
    ORSSerialRequest arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_serialPort_requestDidTimeout_ = objc.registerName(
  "serialPort:requestDidTimeout:",
);
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_fnPtrTrampoline)
        .cast();
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_closureTrampoline)
        .cast();
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  (objc.getBlockClosure(block)
      as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      ))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_listenerTrampoline,
      )
      ..keepIsolateAlive = false;
void
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingTrampoline,
      )
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          ORSSerialRequest,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          ORSSerialRequest,
        )
      >(
        objc.newPointerBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          ORSSerialPort,
          ORSSerialRequest,
        )
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          ) => fn(
            arg0,
            ORSSerialPort.castFromPointer(arg1, retain: true, release: true),
            ORSSerialRequest.castFromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_listenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        ORSSerialRequest.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        ORSSerialRequest.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_blockingListenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        ORSSerialRequest.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, ORSSerialRequest)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ORSSerialPort,
            ORSSerialRequest,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    ORSSerialPort arg1,
    ORSSerialRequest arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_serialPort_didEncounterError_ = objc.registerName(
  "serialPort:didEncounterError:",
);
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) => block.ref.target
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) =>
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_closureCallable =
    ffi.Pointer.fromFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >(_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  (objc.getBlockClosure(block)
      as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      ))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_listenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_listenerTrampoline,
      )
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<ffi.Void> waiter,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
) {
  try {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        ))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingTrampoline,
      )
      ..keepIsolateAlive = false;
ffi.NativeCallable<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>
_ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingListenerCallable =
    ffi.NativeCallable<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >.listener(
        _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingTrampoline,
      )
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
  >
  castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
      >(
        objc.newPointerBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_fnPtrCallable,
          ptr.cast(),
        ),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
      >(
        objc.newClosureBlock(
          _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          ) => fn(
            arg0,
            ORSSerialPort.castFromPointer(arg1, retain: true, release: true),
            objc.NSError.castFromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_listenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSError.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSError.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_blockingListenerCallable
          .nativeFunction
          .cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
      ) => fn(
        arg0,
        ORSSerialPort.castFromPointer(arg1, retain: false, release: true),
        objc.NSError.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _ORSSerialPortBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
    >(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)>`.
extension ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError_CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ORSSerialPort, objc.NSError)
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    ORSSerialPort arg1,
    objc.NSError arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_serialPortWasOpened_ = objc.registerName(
  "serialPortWasOpened:",
);
late final _sel_serialPortWasClosed_ = objc.registerName(
  "serialPortWasClosed:",
);

/// The ORSSerialPortDelegate protocol defines methods to be implemented
/// by the delegate of an `ORSSerialPort` object.
///
/// *Note*: All `ORSSerialPortDelegate` methods are always called on the main queue.
/// If you need to handle them on a background queue, you must dispatch your handling
/// to a background queue in your implementation of the delegate method.
interface class ORSSerialPortDelegate extends objc.ObjCProtocolBase
    implements objc.NSObjectProtocol {
  ORSSerialPortDelegate._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [ORSSerialPortDelegate] that points to the same underlying object as [other].
  ORSSerialPortDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ORSSerialPortDelegate] that wraps the given raw object pointer.
  ORSSerialPortDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ORSSerialPortDelegate].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_ORSSerialPortDelegate,
    );
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_ORSSerialPortDelegate.cast());

  /// Builds an object that implements the ORSSerialPortDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static ORSSerialPortDelegate implement({
    required void Function(ORSSerialPort) serialPortWasRemovedFromSystem_,
    void Function(ORSSerialPort, objc.NSData)? serialPort_didReceiveData_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)?
    serialPort_didReceivePacket_matchingDescriptor_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)?
    serialPort_didReceiveResponse_toRequest_,
    void Function(ORSSerialPort, ORSSerialRequest)?
    serialPort_requestDidTimeout_,
    void Function(ORSSerialPort, objc.NSError)? serialPort_didEncounterError_,
    void Function(ORSSerialPort)? serialPortWasOpened_,
    void Function(ORSSerialPort)? serialPortWasClosed_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'ORSSerialPortDelegate',
    );
    ORSSerialPortDelegate.serialPortWasRemovedFromSystem_.implement(
      builder,
      serialPortWasRemovedFromSystem_,
    );
    ORSSerialPortDelegate.serialPort_didReceiveData_.implement(
      builder,
      serialPort_didReceiveData_,
    );
    ORSSerialPortDelegate.serialPort_didReceivePacket_matchingDescriptor_
        .implement(builder, serialPort_didReceivePacket_matchingDescriptor_);
    ORSSerialPortDelegate.serialPort_didReceiveResponse_toRequest_.implement(
      builder,
      serialPort_didReceiveResponse_toRequest_,
    );
    ORSSerialPortDelegate.serialPort_requestDidTimeout_.implement(
      builder,
      serialPort_requestDidTimeout_,
    );
    ORSSerialPortDelegate.serialPort_didEncounterError_.implement(
      builder,
      serialPort_didEncounterError_,
    );
    ORSSerialPortDelegate.serialPortWasOpened_.implement(
      builder,
      serialPortWasOpened_,
    );
    ORSSerialPortDelegate.serialPortWasClosed_.implement(
      builder,
      serialPortWasClosed_,
    );
    builder.addProtocol($protocol);
    return ORSSerialPortDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the ORSSerialPortDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required void Function(ORSSerialPort) serialPortWasRemovedFromSystem_,
    void Function(ORSSerialPort, objc.NSData)? serialPort_didReceiveData_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)?
    serialPort_didReceivePacket_matchingDescriptor_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)?
    serialPort_didReceiveResponse_toRequest_,
    void Function(ORSSerialPort, ORSSerialRequest)?
    serialPort_requestDidTimeout_,
    void Function(ORSSerialPort, objc.NSError)? serialPort_didEncounterError_,
    void Function(ORSSerialPort)? serialPortWasOpened_,
    void Function(ORSSerialPort)? serialPortWasClosed_,
    bool $keepIsolateAlive = true,
  }) {
    ORSSerialPortDelegate.serialPortWasRemovedFromSystem_.implement(
      builder,
      serialPortWasRemovedFromSystem_,
    );
    ORSSerialPortDelegate.serialPort_didReceiveData_.implement(
      builder,
      serialPort_didReceiveData_,
    );
    ORSSerialPortDelegate.serialPort_didReceivePacket_matchingDescriptor_
        .implement(builder, serialPort_didReceivePacket_matchingDescriptor_);
    ORSSerialPortDelegate.serialPort_didReceiveResponse_toRequest_.implement(
      builder,
      serialPort_didReceiveResponse_toRequest_,
    );
    ORSSerialPortDelegate.serialPort_requestDidTimeout_.implement(
      builder,
      serialPort_requestDidTimeout_,
    );
    ORSSerialPortDelegate.serialPort_didEncounterError_.implement(
      builder,
      serialPort_didEncounterError_,
    );
    ORSSerialPortDelegate.serialPortWasOpened_.implement(
      builder,
      serialPortWasOpened_,
    );
    ORSSerialPortDelegate.serialPortWasClosed_.implement(
      builder,
      serialPortWasClosed_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the ORSSerialPortDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static ORSSerialPortDelegate implementAsListener({
    required void Function(ORSSerialPort) serialPortWasRemovedFromSystem_,
    void Function(ORSSerialPort, objc.NSData)? serialPort_didReceiveData_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)?
    serialPort_didReceivePacket_matchingDescriptor_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)?
    serialPort_didReceiveResponse_toRequest_,
    void Function(ORSSerialPort, ORSSerialRequest)?
    serialPort_requestDidTimeout_,
    void Function(ORSSerialPort, objc.NSError)? serialPort_didEncounterError_,
    void Function(ORSSerialPort)? serialPortWasOpened_,
    void Function(ORSSerialPort)? serialPortWasClosed_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'ORSSerialPortDelegate',
    );
    ORSSerialPortDelegate.serialPortWasRemovedFromSystem_.implementAsListener(
      builder,
      serialPortWasRemovedFromSystem_,
    );
    ORSSerialPortDelegate.serialPort_didReceiveData_.implementAsListener(
      builder,
      serialPort_didReceiveData_,
    );
    ORSSerialPortDelegate.serialPort_didReceivePacket_matchingDescriptor_
        .implementAsListener(
          builder,
          serialPort_didReceivePacket_matchingDescriptor_,
        );
    ORSSerialPortDelegate.serialPort_didReceiveResponse_toRequest_
        .implementAsListener(builder, serialPort_didReceiveResponse_toRequest_);
    ORSSerialPortDelegate.serialPort_requestDidTimeout_.implementAsListener(
      builder,
      serialPort_requestDidTimeout_,
    );
    ORSSerialPortDelegate.serialPort_didEncounterError_.implementAsListener(
      builder,
      serialPort_didEncounterError_,
    );
    ORSSerialPortDelegate.serialPortWasOpened_.implementAsListener(
      builder,
      serialPortWasOpened_,
    );
    ORSSerialPortDelegate.serialPortWasClosed_.implementAsListener(
      builder,
      serialPortWasClosed_,
    );
    builder.addProtocol($protocol);
    return ORSSerialPortDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the ORSSerialPortDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    required void Function(ORSSerialPort) serialPortWasRemovedFromSystem_,
    void Function(ORSSerialPort, objc.NSData)? serialPort_didReceiveData_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)?
    serialPort_didReceivePacket_matchingDescriptor_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)?
    serialPort_didReceiveResponse_toRequest_,
    void Function(ORSSerialPort, ORSSerialRequest)?
    serialPort_requestDidTimeout_,
    void Function(ORSSerialPort, objc.NSError)? serialPort_didEncounterError_,
    void Function(ORSSerialPort)? serialPortWasOpened_,
    void Function(ORSSerialPort)? serialPortWasClosed_,
    bool $keepIsolateAlive = true,
  }) {
    ORSSerialPortDelegate.serialPortWasRemovedFromSystem_.implementAsListener(
      builder,
      serialPortWasRemovedFromSystem_,
    );
    ORSSerialPortDelegate.serialPort_didReceiveData_.implementAsListener(
      builder,
      serialPort_didReceiveData_,
    );
    ORSSerialPortDelegate.serialPort_didReceivePacket_matchingDescriptor_
        .implementAsListener(
          builder,
          serialPort_didReceivePacket_matchingDescriptor_,
        );
    ORSSerialPortDelegate.serialPort_didReceiveResponse_toRequest_
        .implementAsListener(builder, serialPort_didReceiveResponse_toRequest_);
    ORSSerialPortDelegate.serialPort_requestDidTimeout_.implementAsListener(
      builder,
      serialPort_requestDidTimeout_,
    );
    ORSSerialPortDelegate.serialPort_didEncounterError_.implementAsListener(
      builder,
      serialPort_didEncounterError_,
    );
    ORSSerialPortDelegate.serialPortWasOpened_.implementAsListener(
      builder,
      serialPortWasOpened_,
    );
    ORSSerialPortDelegate.serialPortWasClosed_.implementAsListener(
      builder,
      serialPortWasClosed_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the ORSSerialPortDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static ORSSerialPortDelegate implementAsBlocking({
    required void Function(ORSSerialPort) serialPortWasRemovedFromSystem_,
    void Function(ORSSerialPort, objc.NSData)? serialPort_didReceiveData_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)?
    serialPort_didReceivePacket_matchingDescriptor_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)?
    serialPort_didReceiveResponse_toRequest_,
    void Function(ORSSerialPort, ORSSerialRequest)?
    serialPort_requestDidTimeout_,
    void Function(ORSSerialPort, objc.NSError)? serialPort_didEncounterError_,
    void Function(ORSSerialPort)? serialPortWasOpened_,
    void Function(ORSSerialPort)? serialPortWasClosed_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'ORSSerialPortDelegate',
    );
    ORSSerialPortDelegate.serialPortWasRemovedFromSystem_.implementAsBlocking(
      builder,
      serialPortWasRemovedFromSystem_,
    );
    ORSSerialPortDelegate.serialPort_didReceiveData_.implementAsBlocking(
      builder,
      serialPort_didReceiveData_,
    );
    ORSSerialPortDelegate.serialPort_didReceivePacket_matchingDescriptor_
        .implementAsBlocking(
          builder,
          serialPort_didReceivePacket_matchingDescriptor_,
        );
    ORSSerialPortDelegate.serialPort_didReceiveResponse_toRequest_
        .implementAsBlocking(builder, serialPort_didReceiveResponse_toRequest_);
    ORSSerialPortDelegate.serialPort_requestDidTimeout_.implementAsBlocking(
      builder,
      serialPort_requestDidTimeout_,
    );
    ORSSerialPortDelegate.serialPort_didEncounterError_.implementAsBlocking(
      builder,
      serialPort_didEncounterError_,
    );
    ORSSerialPortDelegate.serialPortWasOpened_.implementAsBlocking(
      builder,
      serialPortWasOpened_,
    );
    ORSSerialPortDelegate.serialPortWasClosed_.implementAsBlocking(
      builder,
      serialPortWasClosed_,
    );
    builder.addProtocol($protocol);
    return ORSSerialPortDelegate.castFrom(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the ORSSerialPortDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    required void Function(ORSSerialPort) serialPortWasRemovedFromSystem_,
    void Function(ORSSerialPort, objc.NSData)? serialPort_didReceiveData_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)?
    serialPort_didReceivePacket_matchingDescriptor_,
    void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)?
    serialPort_didReceiveResponse_toRequest_,
    void Function(ORSSerialPort, ORSSerialRequest)?
    serialPort_requestDidTimeout_,
    void Function(ORSSerialPort, objc.NSError)? serialPort_didEncounterError_,
    void Function(ORSSerialPort)? serialPortWasOpened_,
    void Function(ORSSerialPort)? serialPortWasClosed_,
    bool $keepIsolateAlive = true,
  }) {
    ORSSerialPortDelegate.serialPortWasRemovedFromSystem_.implementAsBlocking(
      builder,
      serialPortWasRemovedFromSystem_,
    );
    ORSSerialPortDelegate.serialPort_didReceiveData_.implementAsBlocking(
      builder,
      serialPort_didReceiveData_,
    );
    ORSSerialPortDelegate.serialPort_didReceivePacket_matchingDescriptor_
        .implementAsBlocking(
          builder,
          serialPort_didReceivePacket_matchingDescriptor_,
        );
    ORSSerialPortDelegate.serialPort_didReceiveResponse_toRequest_
        .implementAsBlocking(builder, serialPort_didReceiveResponse_toRequest_);
    ORSSerialPortDelegate.serialPort_requestDidTimeout_.implementAsBlocking(
      builder,
      serialPort_requestDidTimeout_,
    );
    ORSSerialPortDelegate.serialPort_didEncounterError_.implementAsBlocking(
      builder,
      serialPort_didEncounterError_,
    );
    ORSSerialPortDelegate.serialPortWasOpened_.implementAsBlocking(
      builder,
      serialPortWasOpened_,
    );
    ORSSerialPortDelegate.serialPortWasClosed_.implementAsBlocking(
      builder,
      serialPortWasClosed_,
    );
    builder.addProtocol($protocol);
  }

  /// Called when a serial port is removed from the system, e.g. the user unplugs
  /// the USB to serial adapter for the port.
  ///
  /// In this method, you should discard any strong references you have maintained for the
  /// passed in `serialPort` object. The behavior of `ORSSerialPort` instances whose underlying
  /// serial port has been removed from the system is undefined.
  ///
  /// @param serialPort The `ORSSerialPort` instance representing the port that was removed.
  static final serialPortWasRemovedFromSystem_ =
      objc.ObjCProtocolListenableMethod<void Function(ORSSerialPort)>(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPortWasRemovedFromSystem_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPortWasRemovedFromSystem_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.fromFunction(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.listener(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.blocking(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
      );

  /// Called any time new data is received by the serial port from an external source.
  ///
  /// @param serialPort The `ORSSerialPort` instance representing the port that received `data`.
  /// @param data       An `NSData` instance containing the data received.
  static final serialPort_didReceiveData_ =
      objc.ObjCProtocolListenableMethod<
        void Function(ORSSerialPort, objc.NSData)
      >(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPort_didReceiveData_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPort_didReceiveData_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort, objc.NSData) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData.fromFunction(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1, objc.NSData arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(ORSSerialPort, objc.NSData) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData.listener(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1, objc.NSData arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(ORSSerialPort, objc.NSData) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData.blocking(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1, objc.NSData arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// Called when a valid, complete packet matching a descriptor installed with
  /// -startListeningForPacketsMatchingDescriptor: is received.
  ///
  /// @param serialPort		The `ORSSerialPort` instance representing the port that received `packetData`.
  /// @param packetData		The An `NSData` instance containing the received packet data.
  /// @param descriptor		The packet descriptor object for which packetData is a match.
  static final serialPort_didReceivePacket_matchingDescriptor_ =
      objc.ObjCProtocolListenableMethod<
        void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)
      >(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPort_didReceivePacket_matchingDescriptor_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPort_didReceivePacket_matchingDescriptor_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSData arg2,
                ORSSerialPacketDescriptor arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor.listener(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSData arg2,
                ORSSerialPacketDescriptor arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(ORSSerialPort, objc.NSData, ORSSerialPacketDescriptor)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialPacketDescriptor.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSData arg2,
                ORSSerialPacketDescriptor arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Called when a valid, complete response is received for a previously sent request.
  ///
  /// @param serialPort   The `ORSSerialPort` instance representing the port that received `responseData`.
  /// @param responseData The An `NSData` instance containing the received response data.
  /// @param request      The request to which the responseData is a respone.
  static final serialPort_didReceiveResponse_toRequest_ =
      objc.ObjCProtocolListenableMethod<
        void Function(ORSSerialPort, objc.NSData, ORSSerialRequest)
      >(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPort_didReceiveResponse_toRequest_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPort_didReceiveResponse_toRequest_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort, objc.NSData, ORSSerialRequest) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSData arg2,
                ORSSerialRequest arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(ORSSerialPort, objc.NSData, ORSSerialRequest) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSData arg2,
                ORSSerialRequest arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(ORSSerialPort, objc.NSData, ORSSerialRequest) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSData_ORSSerialRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSData arg2,
                ORSSerialRequest arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Called when a the timeout interval for a previously sent request elapses without a valid
  /// response having been received.
  ///
  /// The request can be re-sent by simply calling -sendRequest: again.
  ///
  /// @param serialPort The `ORSSerialPort` instance representing the port through which the request was sent.
  /// @param request    The request for which a response has not been received.
  static final serialPort_requestDidTimeout_ =
      objc.ObjCProtocolListenableMethod<
        void Function(ORSSerialPort, ORSSerialRequest)
      >(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPort_requestDidTimeout_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPort_requestDidTimeout_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort, ORSSerialRequest) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                ORSSerialRequest arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(ORSSerialPort, ORSSerialRequest) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                ORSSerialRequest arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(ORSSerialPort, ORSSerialRequest) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_ORSSerialRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                ORSSerialRequest arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// Called when an error occurs during an operation involving a serial port.
  ///
  /// This method is always used to report errors. No `ORSSerialPort` methods
  /// take a passed in `NSError **` reference because errors may occur asynchonously,
  /// after a method has returned.
  ///
  /// Currently, errors reported using this method are always in the `NSPOSIXErrorDomain`,
  /// and a list of error codes can be found in the system header errno.h.
  ///
  /// The error object's userInfo dictionary contains the following keys:
  ///
  /// - NSLocalizedDescriptionKey - An error message string.
  /// - NSFilePathErrorKey - The device path to the serial port. Same as `[serialPort path]`.
  ///
  /// @param serialPort The `ORSSerialPort` instance for the port
  /// @param error      An `NSError` object containing information about the error.
  static final serialPort_didEncounterError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(ORSSerialPort, objc.NSError)
      >(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPort_didEncounterError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPort_didEncounterError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSError arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(ORSSerialPort, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSError arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(ORSSerialPort, objc.NSError) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                ORSSerialPort arg1,
                objc.NSError arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// Called when a serial port is successfully opened.
  ///
  /// @param serialPort The `ORSSerialPort` instance representing the port that was opened.
  static final serialPortWasOpened_ =
      objc.ObjCProtocolListenableMethod<void Function(ORSSerialPort)>(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPortWasOpened_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPortWasOpened_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.fromFunction(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.listener(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.blocking(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
      );

  /// Called when a serial port was closed (e.g. because `-close`) was called.
  ///
  /// When an ORSSerialPort instance is closed, its queued requests are cancelled, and
  /// its pending request is discarded. This is done _after_ the call to `-serialPortWasClosed:`.
  /// If upon later reopening you may need to resend those requests, you
  /// should retrieve and store them in your implementation of this method.
  ///
  /// @param serialPort The `ORSSerialPort` instance representing the port that was closed.
  static final serialPortWasClosed_ =
      objc.ObjCProtocolListenableMethod<void Function(ORSSerialPort)>(
        _protocol_ORSSerialPortDelegate,
        _sel_serialPortWasClosed_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >
            >(_ORSSerialPortBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_ORSSerialPortDelegate,
          _sel_serialPortWasClosed_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.fromFunction(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.listener(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
        (void Function(ORSSerialPort) func) =>
            ObjCBlock_ffiVoid_ffiVoid_ORSSerialPort.blocking(
              (ffi.Pointer<ffi.Void> _, ORSSerialPort arg1) => func(arg1),
            ),
      );
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_pendingRequest = objc.registerName("pendingRequest");
late final _sel_queuedRequests = objc.registerName("queuedRequests");
late final _sel_packetDescriptors = objc.registerName("packetDescriptors");
late final _sel_isOpen = objc.registerName("isOpen");
late final _sel_path = objc.registerName("path");
late final _sel_IOKitDevice = objc.registerName("IOKitDevice");
final _objc_msgSend_3pyzne = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedInt Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_name = objc.registerName("name");
late final _sel_baudRate = objc.registerName("baudRate");
late final _sel_setBaudRate_ = objc.registerName("setBaudRate:");
late final _sel_allowsNonStandardBaudRates = objc.registerName(
  "allowsNonStandardBaudRates",
);
late final _sel_setAllowsNonStandardBaudRates_ = objc.registerName(
  "setAllowsNonStandardBaudRates:",
);
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_numberOfStopBits = objc.registerName("numberOfStopBits");
late final _sel_setNumberOfStopBits_ = objc.registerName(
  "setNumberOfStopBits:",
);
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_numberOfDataBits = objc.registerName("numberOfDataBits");
late final _sel_setNumberOfDataBits_ = objc.registerName(
  "setNumberOfDataBits:",
);
late final _sel_shouldEchoReceivedData = objc.registerName(
  "shouldEchoReceivedData",
);
late final _sel_setShouldEchoReceivedData_ = objc.registerName(
  "setShouldEchoReceivedData:",
);
late final _sel_parity = objc.registerName("parity");
final _objc_msgSend_1s2qz0v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setParity_ = objc.registerName("setParity:");
final _objc_msgSend_uezx3j = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_usesRTSCTSFlowControl = objc.registerName(
  "usesRTSCTSFlowControl",
);
late final _sel_setUsesRTSCTSFlowControl_ = objc.registerName(
  "setUsesRTSCTSFlowControl:",
);
late final _sel_usesDTRDSRFlowControl = objc.registerName(
  "usesDTRDSRFlowControl",
);
late final _sel_setUsesDTRDSRFlowControl_ = objc.registerName(
  "setUsesDTRDSRFlowControl:",
);
late final _sel_usesDCDOutputFlowControl = objc.registerName(
  "usesDCDOutputFlowControl",
);
late final _sel_setUsesDCDOutputFlowControl_ = objc.registerName(
  "setUsesDCDOutputFlowControl:",
);
late final _sel_RTS = objc.registerName("RTS");
late final _sel_setRTS_ = objc.registerName("setRTS:");
late final _sel_DTR = objc.registerName("DTR");
late final _sel_setDTR_ = objc.registerName("setDTR:");
late final _sel_CTS = objc.registerName("CTS");
late final _sel_DSR = objc.registerName("DSR");
late final _sel_DCD = objc.registerName("DCD");

/// The ORSSerialPort class represents a serial port, and includes methods to
/// configure, open and close a port, and send and receive data to and from
/// a port.
///
/// There is a 1:1 correspondence between port devices on the
/// system and instances of `ORSSerialPort`. That means that repeated requests
/// for a port object for a given device or device path will return the same
/// instance of `ORSSerialPort`.
///
/// Opening a Port and Setting It Up
/// --------------------------------
///
/// You can get an `ORSSerialPort` instance either of two ways. The easiest
/// is to use `ORSSerialPortManager`'s `availablePorts` array. The other way
/// is to get a new `ORSSerialPort` instance using the serial port's BSD device path:
///
/// ORSSerialPort *port = [ORSSerialPort serialPortWithPath:@"/dev/cu.KeySerial1"];
///
/// Note that you must give `+serialPortWithPath:` the full path to the
/// device, as shown in the example above.
///
///
/// After you've got a port instance, you can open it with the `-open`
/// method. When you're done using the port, close it using the `-close`
/// method.
///
/// Port settings such as baud rate, number of stop bits, parity, and flow
/// control settings can be set using the various properties `ORSSerialPort`
/// provides. Note that all of these properties are Key Value Observing
/// (KVO) compliant. This KVO compliance also applies to read-only
/// properties for reading the state of the CTS, DSR and DCD pins. Among
/// other things, this means it's easy to be notified when the state of one
/// of these pins changes, without having to continually poll them, as well
/// as making them easy to connect to a UI with Cocoa bindings.
///
/// Sending Data
/// ------------
///
/// Send data by passing an `NSData` object to the `-sendData:` method:
///
/// NSData *dataToSend = [self.sendTextField.stringValue dataUsingEncoding:NSUTF8StringEncoding];
/// [self.serialPort sendData:dataToSend];
///
/// Receiving Data
/// --------------
///
/// To receive data, you must implement the `ORSSerialPortDelegate`
/// protocol's `-serialPort:didReceiveData:` method, and set the
/// `ORSSerialPort` instance's delegate property. As noted in the documentation
/// for ORSSerialPortDelegate, this method is always called on the main queue.
/// An example implementation is included below:
///
/// - (void)serialPort:(ORSSerialPort *)serialPort didReceiveData:(NSData *)data
/// {
/// NSString *string = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
/// [self.receivedDataTextView.textStorage.mutableString appendString:string];
/// [self.receivedDataTextView setNeedsDisplay:YES];
/// }
class ORSSerialPort extends objc.NSObject {
  ORSSerialPort._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ORSSerialPort] that points to the same underlying object as [other].
  ORSSerialPort.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ORSSerialPort] that wraps the given raw object pointer.
  ORSSerialPort.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ORSSerialPort].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_ORSSerialPort,
    );
  }

  /// Returns an `ORSSerialPort` instance representing the serial port at `devicePath`.
  ///
  /// `devicePath` must be the full, callout (cu.) or tty (tty.) path to an available
  /// serial port device on the system.
  ///
  /// @param devicePath The full path (e.g. /dev/cu.usbserial) to the device.
  ///
  /// @return An initalized `ORSSerialPort` instance, or nil if there was an error.
  ///
  /// @see -[ORSSerialPortManager availablePorts]
  /// @see -initWithPath:
  static ORSSerialPort? serialPortWithPath(objc.NSString devicePath) {
    final _ret = _objc_msgSend_1sotr3r(
      _class_ORSSerialPort,
      _sel_serialPortWithPath_,
      devicePath.ref.pointer,
    );
    return _ret.address == 0
        ? null
        : ORSSerialPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an `ORSSerialPort` instance for the serial port represented by `device`.
  ///
  /// Generally, `+serialPortWithPath:` is the method to use to get port instances
  /// programatically. This method may be useful if you're doing your own
  /// device discovery with IOKit functions, or otherwise have an IOKit port object
  /// you want to "turn into" an ORSSerialPort. Most people will not use this method
  /// directly.
  ///
  /// @param device An IOKit port object representing the serial port device.
  ///
  /// @return An initalized `ORSSerialPort` instance, or nil if there was an error.
  ///
  /// @see -[ORSSerialPortManager availablePorts]
  /// @see +serialPortWithPath:
  static ORSSerialPort? serialPortWithDevice(int device) {
    final _ret = _objc_msgSend_degb40(
      _class_ORSSerialPort,
      _sel_serialPortWithDevice_,
      device,
    );
    return _ret.address == 0
        ? null
        : ORSSerialPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns an `ORSSerialPort` instance representing the serial port at `devicePath`.
  ///
  /// `devicePath` must be the full, callout (cu.) or tty (tty.) path to an available
  /// serial port device on the system.
  ///
  /// @param devicePath The full path (e.g. /dev/cu.usbserial) to the device.
  ///
  /// @return An initalized `ORSSerialPort` instance, or nil if there was an error.
  ///
  /// @see -[ORSSerialPortManager availablePorts]
  /// @see +serialPortWithPath:
  ORSSerialPort? initWithPath(objc.NSString devicePath) {
    final _ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPath_,
      devicePath.ref.pointer,
    );
    return _ret.address == 0
        ? null
        : ORSSerialPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns an `ORSSerialPort` instance for the serial port represented by `device`.
  ///
  /// Generally, `-initWithPath:` is the method to use to get port instances
  /// programatically. This method may be useful if you're doing your own
  /// device discovery with IOKit functions, or otherwise have an IOKit port object
  /// you want to "turn into" an ORSSerialPort. Most people will not use this method
  /// directly.
  ///
  /// @param device An IOKit port object representing the serial port device.
  ///
  /// @return An initalized `ORSSerialPort` instance, or nil if there was an error.
  ///
  /// @see -[ORSSerialPortManager availablePorts]
  /// @see -initWithPath:
  ORSSerialPort? initWithDevice(int device) {
    final _ret = _objc_msgSend_degb40(
      this.ref.retainAndReturnPointer(),
      _sel_initWithDevice_,
      device,
    );
    return _ret.address == 0
        ? null
        : ORSSerialPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// Opens the port represented by the receiver.
  ///
  /// If this method succeeds, the ORSSerialPortDelegate method `-serialPortWasOpened:` will
  /// be called.
  ///
  /// If opening the port fails, the ORSSerialPortDelegate method `-serialPort:didEncounterError:` will
  /// be called.
  void open() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_open);
  }

  /// Closes the port represented by the receiver.
  ///
  /// If the port is closed successfully, the ORSSerialPortDelegate method `-serialPortWasClosed:` will
  /// be called before this method returns.
  ///
  /// @return YES if closing the port was closed successfully, NO if closing the port failed.
  bool close() {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_close);
  }

  /// Should never have been called in client code, anyway.
  void cleanup() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cleanup);
  }

  /// Closes the port and cleans up.
  ///
  /// This method should never be called directly. Call `-close` to close a port instead.
  void cleanupAfterSystemRemoval() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cleanupAfterSystemRemoval);
  }

  /// Sends data out through the serial port represented by the receiver.
  ///
  /// This method attempts to send all data synchronously. That is, the method
  /// will not return until all passed in data has been sent, or an error has occurred.
  ///
  /// If an error occurs, the ORSSerialPortDelegate method `-serialPort:didEncounterError:` will
  /// be called. The exception to this is if sending data fails because the port
  /// is closed. In that case, this method returns NO, but `-serialPort:didEncounterError:`
  /// is *not* called. You can ensure that the port is open by calling `-isOpen` before
  /// calling this method.
  ///
  /// @note This method can take a long time to return when a very large amount of data
  /// is passed in, due to the relatively slow nature of serial communication. It is better
  /// to send data in discrete short packets if possible.
  ///
  /// @param data An `NSData` object containing the data to be sent.
  ///
  /// @return YES if sending data succeeded, NO if an error occurred.
  bool sendData(objc.NSData data) {
    return _objc_msgSend_19nvye5(
      this.ref.pointer,
      _sel_sendData_,
      data.ref.pointer,
    );
  }

  /// Sends the data in request, and begins watching for a valid response to the request,
  /// to be delivered to the delegate.
  ///
  /// If the receiver already has one or more pending requests, the request is queued to be
  /// sent after all previous requests have received valid responses or have timed out
  /// and this method will return YES. If there are no pending requests, the request
  /// is sent immediately and NO is returned if an error occurs.
  ///
  /// @note This method calls through to -sendData:, and the same caveat
  /// about it taking a long time to send very large requests applies.
  ///
  /// @param request An ORSSerialRequest instance including the data to be sent.
  ///
  /// @return YES if sending the request's data succeeded, NO if an error occurred.
  bool sendRequest(ORSSerialRequest request) {
    return _objc_msgSend_19nvye5(
      this.ref.pointer,
      _sel_sendRequest_,
      request.ref.pointer,
    );
  }

  /// Requests the cancellation of a queued (not yet sent) request. The request
  /// is removed from the requests queue and will not be sent.
  ///
  /// Note that a pending request cannot be cancelled, as it has already been sent and is
  /// awaiting a response. If a pending request is passed in, this method will simply
  /// do nothing. Because the requests queue is handled in the background, occasionally
  /// a request may leave the queue and becoming pending after this method is called,
  /// causing cancellation to fail. If you need to absolutely guarantee that a request
  /// is not sent you should avoid sending it rather than depending on later cancellation.
  ///
  /// @param request The pending request to be cancelled.
  void cancelQueuedRequest(ORSSerialRequest request) {
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_cancelQueuedRequest_,
      request.ref.pointer,
    );
  }

  /// Cancels all queued requests. The requests queue is emptied.
  ///
  /// Note that if there is a pending request, it is not cancelled, as it has already
  /// been sent and is awaiting a response.
  void cancelAllQueuedRequests() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancelAllQueuedRequests);
  }

  /// Tells the receiver to begin listening for incoming packets matching the specified
  /// descriptor.
  ///
  /// When incoming data that constitutes a packet as described by descriptor is received,
  /// the delegate method -serialPort:didReceivePacket:matchingDescriptor: will be called.
  ///
  /// @param descriptor An ORSerialPacketDescriptor instance describing the packets the receiver
  /// should listen for.
  ///
  /// @see -stopListeningForPacketsMatchingDescriptor:
  /// @see -serialPort:didReceivePacket:matchingDescriptor:
  void startListeningForPacketsMatchingDescriptor(
    ORSSerialPacketDescriptor descriptor,
  ) {
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_startListeningForPacketsMatchingDescriptor_,
      descriptor.ref.pointer,
    );
  }

  /// Tells the receiver to stop listening for incoming packets matching the specified
  /// descriptor.
  ///
  /// @note The passed in descriptor must be the exact same instance as was previously
  /// provided to -startListeningForPacketsMatchingDescriptor:
  ///
  /// @param descriptor An ORSSerialPacketDescriptor instance previously passed to
  /// -startListeningForPacketsMatchingDescriptor:
  ///
  /// @see -startListeningForPacketsMatchingDescriptor:
  void stopListeningForPacketsMatchingDescriptor(
    ORSSerialPacketDescriptor descriptor,
  ) {
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_stopListeningForPacketsMatchingDescriptor_,
      descriptor.ref.pointer,
    );
  }

  /// delegate
  ORSSerialPortDelegate? get delegate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : ORSSerialPortDelegate.castFromPointer(
            _ret,
            retain: true,
            release: true,
          );
  }

  /// setDelegate:
  set delegate(ORSSerialPortDelegate? value) {
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_setDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// The previously-sent request for which the port is awaiting a response, or nil
  /// if there is no pending request.
  ///
  /// This property can be observed using Key Value Observing.
  ORSSerialRequest? get pendingRequest {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pendingRequest);
    return _ret.address == 0
        ? null
        : ORSSerialRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// Requests in the queue waiting to be sent, or an empty array if there are no queued requests.
  /// Requests are sent from the queue in FIFO order. That is, the first request in the array
  /// returned by this property is the next request to be sent.
  ///
  /// This property can be observed using Key Value Observing.
  ///
  /// @note This array does not contain the pending request, a sent request for which
  /// the port is awaiting a response.
  objc.NSArray get queuedRequests {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_queuedRequests);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// An array of packet descriptors for which the port is listening.
  ///
  /// Returns an empty array if no packet descriptors are installed.
  objc.NSArray get packetDescriptors {
    final _ret = _objc_msgSend_151sglz(
      this.ref.pointer,
      _sel_packetDescriptors,
    );
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// A Boolean value that indicates whether the port is open. (read-only)
  bool get open$1 {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOpen);
  }

  /// An string representation of the device path for the serial port represented by the receiver. (read-only)
  objc.NSString get path {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_path);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The IOKit port object for the serial port device represented by the receiver. (read-only)
  int get IOKitDevice {
    return _objc_msgSend_3pyzne(this.ref.pointer, _sel_IOKitDevice);
  }

  /// The name of the serial port.
  ///
  /// Can be presented to the user, e.g. in a serial port selection pop up menu.
  objc.NSString get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The baud rate for the port.
  ///
  /// Unless supportsNonStandardBaudRates is YES,
  /// this value should be one of the values defined in termios.h:
  ///
  /// - 0
  /// - 50
  /// - 75
  /// - 110
  /// - 134
  /// - 150
  /// - 200
  /// - 300
  /// - 600
  /// - 1200
  /// - 1800
  /// - 2400
  /// - 4800
  /// - 9600
  /// - 19200
  /// - 38400
  /// - 7200
  /// - 14400
  /// - 28800
  /// - 57600
  /// - 76800
  /// - 115200
  /// - 230400
  objc.NSNumber get baudRate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_baudRate);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// The baud rate for the port.
  ///
  /// Unless supportsNonStandardBaudRates is YES,
  /// this value should be one of the values defined in termios.h:
  ///
  /// - 0
  /// - 50
  /// - 75
  /// - 110
  /// - 134
  /// - 150
  /// - 200
  /// - 300
  /// - 600
  /// - 1200
  /// - 1800
  /// - 2400
  /// - 4800
  /// - 9600
  /// - 19200
  /// - 38400
  /// - 7200
  /// - 14400
  /// - 28800
  /// - 57600
  /// - 76800
  /// - 115200
  /// - 230400
  set baudRate(objc.NSNumber value) {
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_setBaudRate_,
      value.ref.pointer,
    );
  }

  /// Whether or not the port allows setting non-standard baud rates.
  /// Set this property to YES to allow setting non-standard baud rates
  /// for the port. The default is NO.
  ///
  /// @note Support for non-standard baud rates
  /// depends on the serial hardware and driver being used. Even
  /// for hardware/drivers that support non-standard baud rates,
  /// it may be that not all baud rates are supported.
  /// ORSSerialPort may *not* report an error when setting
  /// a non-standard baud rate, nor will the baudRate getter return
  /// the actual baud rate when non-standard baud rates are
  /// used. This option should only be used when necessary,
  /// and should be used with caution.
  bool get allowsNonStandardBaudRates {
    return _objc_msgSend_91o635(
      this.ref.pointer,
      _sel_allowsNonStandardBaudRates,
    );
  }

  /// Whether or not the port allows setting non-standard baud rates.
  /// Set this property to YES to allow setting non-standard baud rates
  /// for the port. The default is NO.
  ///
  /// @note Support for non-standard baud rates
  /// depends on the serial hardware and driver being used. Even
  /// for hardware/drivers that support non-standard baud rates,
  /// it may be that not all baud rates are supported.
  /// ORSSerialPort may *not* report an error when setting
  /// a non-standard baud rate, nor will the baudRate getter return
  /// the actual baud rate when non-standard baud rates are
  /// used. This option should only be used when necessary,
  /// and should be used with caution.
  set allowsNonStandardBaudRates(bool value) {
    _objc_msgSend_1s56lr9(
      this.ref.pointer,
      _sel_setAllowsNonStandardBaudRates_,
      value,
    );
  }

  /// The number of stop bits. Values other than 1 or 2 are invalid.
  int get numberOfStopBits {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_numberOfStopBits);
  }

  /// The number of stop bits. Values other than 1 or 2 are invalid.
  set numberOfStopBits(int value) {
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_setNumberOfStopBits_, value);
  }

  /// The number of data bits. Values other than 5, 6, 7, or 8 are ignored.
  int get numberOfDataBits {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_numberOfDataBits);
  }

  /// The number of data bits. Values other than 5, 6, 7, or 8 are ignored.
  set numberOfDataBits(int value) {
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_setNumberOfDataBits_, value);
  }

  ///
  bool get shouldEchoReceivedData {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldEchoReceivedData);
  }

  ///
  set shouldEchoReceivedData(bool value) {
    _objc_msgSend_1s56lr9(
      this.ref.pointer,
      _sel_setShouldEchoReceivedData_,
      value,
    );
  }

  /// The parity setting for the port. Possible values are:
  ///
  /// - ORSSerialPortParityNone
  /// - ORSSerialPortParityOdd
  /// - ORSSerialPortParityEven
  ORSSerialPortParity get parity {
    final _ret = _objc_msgSend_1s2qz0v(this.ref.pointer, _sel_parity);
    return ORSSerialPortParity.fromValue(_ret);
  }

  /// The parity setting for the port. Possible values are:
  ///
  /// - ORSSerialPortParityNone
  /// - ORSSerialPortParityOdd
  /// - ORSSerialPortParityEven
  set parity(ORSSerialPortParity value) {
    _objc_msgSend_uezx3j(this.ref.pointer, _sel_setParity_, value.value);
  }

  /// A Boolean value indicating whether the serial port uses RTS/CTS Flow Control.
  bool get usesRTSCTSFlowControl {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_usesRTSCTSFlowControl);
  }

  /// A Boolean value indicating whether the serial port uses RTS/CTS Flow Control.
  set usesRTSCTSFlowControl(bool value) {
    _objc_msgSend_1s56lr9(
      this.ref.pointer,
      _sel_setUsesRTSCTSFlowControl_,
      value,
    );
  }

  /// A Boolean value indicating whether the serial port uses DTR/DSR Flow Control.
  bool get usesDTRDSRFlowControl {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_usesDTRDSRFlowControl);
  }

  /// A Boolean value indicating whether the serial port uses DTR/DSR Flow Control.
  set usesDTRDSRFlowControl(bool value) {
    _objc_msgSend_1s56lr9(
      this.ref.pointer,
      _sel_setUsesDTRDSRFlowControl_,
      value,
    );
  }

  /// A Boolean value indicating whether the serial port uses DCD Flow Control.
  bool get usesDCDOutputFlowControl {
    return _objc_msgSend_91o635(
      this.ref.pointer,
      _sel_usesDCDOutputFlowControl,
    );
  }

  /// A Boolean value indicating whether the serial port uses DCD Flow Control.
  set usesDCDOutputFlowControl(bool value) {
    _objc_msgSend_1s56lr9(
      this.ref.pointer,
      _sel_setUsesDCDOutputFlowControl_,
      value,
    );
  }

  /// The state of the serial port's RTS pin.
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  bool get RTS {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_RTS);
  }

  /// The state of the serial port's RTS pin.
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  set RTS(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setRTS_, value);
  }

  /// The state of the serial port's DTR pin.
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  bool get DTR {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_DTR);
  }

  /// The state of the serial port's DTR pin.
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  set DTR(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDTR_, value);
  }

  /// The state of the serial port's CTS pin.
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  bool get CTS {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_CTS);
  }

  /// The state of the serial port's DSR pin. (read-only)
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  bool get DSR {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_DSR);
  }

  /// The state of the serial port's DCD pin. (read-only)
  ///
  /// - YES means 1 or high state.
  /// - NO means 0 or low state.
  ///
  /// This property is observable using Key Value Observing.
  bool get DCD {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_DCD);
  }

  /// init
  ORSSerialPort init() {
    objc.checkOsVersionInternal(
      'ORSSerialPort.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_151sglz(
      this.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return ORSSerialPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static ORSSerialPort new$() {
    final _ret = _objc_msgSend_151sglz(_class_ORSSerialPort, _sel_new);
    return ORSSerialPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static ORSSerialPort allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
      _class_ORSSerialPort,
      _sel_allocWithZone_,
      zone,
    );
    return ORSSerialPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static ORSSerialPort alloc() {
    final _ret = _objc_msgSend_151sglz(_class_ORSSerialPort, _sel_alloc);
    return ORSSerialPort.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  ORSSerialPort self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ORSSerialPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  ORSSerialPort retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ORSSerialPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  ORSSerialPort autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ORSSerialPort.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of ORSSerialPort constructed with the default `new` method.
  factory ORSSerialPort() => new$();
}

late final _class_ORSSerialPortManager = objc.getClass("ORSSerialPortManager");
late final _sel_sharedSerialPortManager = objc.registerName(
  "sharedSerialPortManager",
);
late final _sel_availablePorts = objc.registerName("availablePorts");

/// `ORSSerialPortManager` is a singleton class (one instance per
/// application) that can be used to get a list of available serial ports.
/// It will also handle closing open serial ports when the Mac goes to
/// sleep, and reopening them automatically on wake. This prevents problems
/// I've seen with serial port drivers that can hang if the port is left
/// open when putting the machine to sleep. Note that using
/// `ORSSerialPortManager` is optional. It provides some nice functionality,
/// but only `ORSSerialPort` is necessary to simply send and received data.
///
/// Using ORSSerialPortManager
/// --------------------------
///
/// To get the shared serial port
/// manager:
///
/// ORSSerialPortManager *portManager = [ORSSerialPortManager sharedSerialPortManager];
///
/// To get a list of available ports:
///
/// NSArray *availablePorts = portManager.availablePorts;
///
/// Notifications
/// -------------
///
/// `ORSSerialPort` posts notifications when a port is added to or removed from the system.
/// `ORSSerialPortsWereConnectedNotification` is posted when one or more ports
/// are added to the system. `ORSSerialPortsWereDisconnectedNotification` is posted when
/// one ore more ports are removed from the system. The user info dictionary for each
/// notification contains the list of ports added or removed. The keys to access these array
/// are `ORSConnectedSerialPortsKey`, and `ORSDisconnectedSerialPortsKey` respectively.
///
/// KVO Compliance
/// --------------
///
/// `ORSSerialPortManager` is Key-Value Observing (KVO) compliant for its
/// `availablePorts` property. This means that you can observe
/// `availablePorts` to be notified when ports are added to or removed from
/// the system. This also means that you can easily bind UI elements to the
/// serial port manager's `availablePorts` property using Cocoa-bindings.
/// This makes it easy to create a popup menu that displays available serial
/// ports and updates automatically, for example.
///
/// Close-On-Sleep
/// --------------
///
/// `ORSSerialPortManager`'s close-on-sleep, reopen-on-wake functionality is
/// automatic. The only thing necessary to enable it is to make sure that
/// the singleton instance of `ORSSerialPortManager` has been created by
/// calling `+sharedSerialPortManager` at least once. Note that this
/// behavior is only available in Cocoa apps, and is disabled when
/// ORSSerialPort is used in a command-line only app.
class ORSSerialPortManager extends objc.NSObject {
  ORSSerialPortManager._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [ORSSerialPortManager] that points to the same underlying object as [other].
  ORSSerialPortManager.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [ORSSerialPortManager] that wraps the given raw object pointer.
  ORSSerialPortManager.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [ORSSerialPortManager].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
      obj.ref.pointer,
      _sel_isKindOfClass_,
      _class_ORSSerialPortManager,
    );
  }

  /// Returns the shared (singleton) serial port manager object.
  ///
  /// @return The shared serial port manager.
  static ORSSerialPortManager sharedSerialPortManager() {
    final _ret = _objc_msgSend_151sglz(
      _class_ORSSerialPortManager,
      _sel_sharedSerialPortManager,
    );
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// An array containing ORSSerialPort instances representing the
  /// serial ports available on the system. (read-only)
  ///
  /// As explained above, this property is Key Value Observing
  /// compliant, and can be bound to for example an NSPopUpMenu
  /// to easily give the user a way to select an available port
  /// on the system.
  objc.NSArray get availablePorts {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_availablePorts);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  ORSSerialPortManager init() {
    objc.checkOsVersionInternal(
      'ORSSerialPortManager.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final _ret = _objc_msgSend_151sglz(
      this.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static ORSSerialPortManager new$() {
    final _ret = _objc_msgSend_151sglz(_class_ORSSerialPortManager, _sel_new);
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static ORSSerialPortManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
      _class_ORSSerialPortManager,
      _sel_allocWithZone_,
      zone,
    );
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// alloc
  static ORSSerialPortManager alloc() {
    final _ret = _objc_msgSend_151sglz(_class_ORSSerialPortManager, _sel_alloc);
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: false,
      release: true,
    );
  }

  /// self
  ORSSerialPortManager self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// retain
  ORSSerialPortManager retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// autorelease
  ORSSerialPortManager autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return ORSSerialPortManager.castFromPointer(
      _ret,
      retain: true,
      release: true,
    );
  }

  /// Returns a new instance of ORSSerialPortManager constructed with the default `new` method.
  factory ORSSerialPortManager() => new$();
}
